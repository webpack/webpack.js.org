"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3049],{3049:function(e,n,s){s.r(n),s.d(n,{default:function(){return a}});var t=s(2540),o=s(3317);function i(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"When contributing to the core repo, writing a loader/plugin, or even working on a complex project, debugging tools can be central to your workflow. Whether the problem is slow performance on a large project or an unhelpful traceback, the following utilities can make figuring it out less painful."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsxs)(n.a,{href:"/api/stats",children:[(0,t.jsx)(n.code,{children:"stats"})," data"]})," made available through ",(0,t.jsx)(n.a,{href:"/api/node/#stats-object",children:"Node"})," and the ",(0,t.jsx)(n.a,{href:"/api/cli/#common-options",children:"CLI"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Chrome ",(0,t.jsx)(n.strong,{children:"DevTools"})," and the latest Node.js version."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{children:[(0,t.jsx)(n.span,{id:"stats"}),"Stats",(0,t.jsx)(n.a,{href:"#stats","aria-hidden":"true",tabIndex:"-1",children:(0,t.jsx)(n.span,{className:"header-link"})})]}),"\n",(0,t.jsxs)(n.p,{children:["Whether you want to sift through ",(0,t.jsx)(n.a,{href:"/api/stats",children:"this data"})," manually or use a tool to process it, the ",(0,t.jsx)(n.code,{children:"stats"})," data can be extremely useful when debugging build issues. We won't go in depth here as there's an ",(0,t.jsx)(n.a,{href:"/api/stats",children:"entire page"})," dedicated to its contents, but know that you can use it to find the following information:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The contents of every module."}),"\n",(0,t.jsx)(n.li,{children:"The modules contained within every chunk."}),"\n",(0,t.jsx)(n.li,{children:"Per module compilation and resolving stats."}),"\n",(0,t.jsx)(n.li,{children:"Build errors and warnings."}),"\n",(0,t.jsx)(n.li,{children:"The relationships between modules."}),"\n",(0,t.jsx)(n.li,{children:"And much more..."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["On top of that, the official ",(0,t.jsx)(n.a,{href:"https://github.com/webpack/analyse",children:"analyze tool"})," and ",(0,t.jsx)(n.a,{href:"/guides/code-splitting/#bundle-analysis",children:"various others"})," will accept this data and visualize it in various ways."]}),"\n",(0,t.jsxs)(n.h2,{children:[(0,t.jsx)(n.span,{id:"devtools"}),"DevTools",(0,t.jsx)(n.a,{href:"#devtools","aria-hidden":"true",tabIndex:"-1",children:(0,t.jsx)(n.span,{className:"header-link"})})]}),"\n",(0,t.jsxs)(n.p,{children:["While ",(0,t.jsx)(n.a,{href:"https://nodejs.org/api/console.html",children:(0,t.jsx)(n.code,{children:"console"})})," statements may work well in straightforward scenarios, sometimes a more robust solution is needed. As most front-end developers already know, Chrome DevTools are a life saver when debugging web applications, ",(0,t.jsx)(n.em,{children:"but they donâ€™t have to stop there"}),". As of Node v6.3.0+, developers can use the built-in ",(0,t.jsx)(n.code,{children:"--inspect"})," flag to debug a node program in DevTools."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's start by invoking webpack with the ",(0,t.jsx)(n.code,{children:"node --inspect"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that we cannot run npm ",(0,t.jsx)(n.code,{children:"scripts"}),", e.g. ",(0,t.jsx)(n.code,{children:"npm run build"}),", so we'll have to specify the full ",(0,t.jsx)(n.code,{children:"node_modules"})," path:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"hljs language-bash",children:"node --inspect ./node_modules/webpack/bin/webpack.js"})}),"\n",(0,t.jsx)(n.p,{children:"Which should output something like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsxs)(n.code,{className:"hljs language-bash",children:["Debugger listening on ws://127.0.0.1:9229/c624201a-250f-416e-a018-300bbec7be2c\nFor ",(0,t.jsx)(n.span,{className:"token builtin class-name",children:"help"})," see https://nodejs.org/en/docs/inspector"]})}),"\n",(0,t.jsxs)(n.p,{children:["Now jump to ",(0,t.jsx)(n.code,{children:"chrome://inspect"})," in the browser and you should see any active scripts you've inspected under the ",(0,t.jsx)(n.em,{children:"Remote Target"}),' header. Click the "inspect" link under each script to open a dedicated debugger or the ',(0,t.jsx)(n.em,{children:"Open dedicated DevTools for Node"})," link for a session that will connect automatically. You can also check out the ",(0,t.jsx)(n.a,{href:"https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj",children:"NiM extension"}),", a handy Chrome plugin that will automatically open a DevTools tab every time you ",(0,t.jsx)(n.code,{children:"--inspect"})," a script."]}),"\n",(0,t.jsxs)(n.p,{children:["We recommend using the ",(0,t.jsx)(n.code,{children:"--inspect-brk"})," flag which will break on the first statement of the script allowing you to go through the source to set breakpoints and start/stop the build as you please. Also, don't forget that you can still pass arguments to the script. For example, if you have multiple configuration files you could pass ",(0,t.jsx)(n.code,{children:"--config webpack.prod.js"})," to specify the configuration you'd like to debug."]})]})}function a(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}}}]);