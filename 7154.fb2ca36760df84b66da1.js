"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7154],{7154:function(e,t,a){a.r(t),a(7378);var n=a(2682);function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}function o(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",s({components:t},a),(0,n.kt)("p",null,"Any time one file depends on another, webpack treats this as a ",(0,n.kt)("em",{parentName:"p"},"dependency"),". This allows webpack to take non-code assets, such as images or web fonts, and also provide them as ",(0,n.kt)("em",{parentName:"p"},"dependencies")," for your application."),(0,n.kt)("p",null,"When webpack processes your application, it starts from a list of modules defined on the command line or in its configuration file.\nStarting from these ",(0,n.kt)("a",{href:"/concepts/entry-points/",parentName:"p"},(0,n.kt)("em",{parentName:"a"},"entry points")),", webpack recursively builds a ",(0,n.kt)("em",{parentName:"p"},"dependency graph")," that includes every module your application needs, then bundles all of those modules into a small number of ",(0,n.kt)("em",{parentName:"p"},"bundles")," - often, only one - to be loaded by the browser."),(0,n.kt)("aside",{className:"tip"},(0,n.kt)("h6",{className:"tip__prefix",parentName:"aside"},"tip"),(0,n.kt)("p",{parentName:"aside"},"Bundling your application is especially powerful for ",(0,n.kt)("em",{parentName:"p"},"HTTP/1.1")," clients, as it minimizes the number of times your app has to wait while the browser starts a new request. For ",(0,n.kt)("em",{parentName:"p"},"HTTP/2"),", you can also use ",(0,n.kt)("a",{href:"/guides/code-splitting/",parentName:"p"},"Code Splitting")," to achieve best results.")))}o.isMDXComponent=!0,t.default=o}}]);